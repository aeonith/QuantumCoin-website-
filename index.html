<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>QuantumCoin™ — Post-Quantum Proof-of-Work Layer-1</title>
  <meta name="description" content="QuantumCoin™ (QC) is a post-quantum Proof-of-Work Layer-1 with a 22,000,000 hard cap, ~10-minute blocks, and 2-year halvings (~66 years). RevStop™ provides owner-local protection.">
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
</head>
<body>

<header class="top">
  <div class="brand">
    <span class="spark"></span>
    <span class="name">QuantumCoin™</span>
  </div>
  <nav class="tabs">
    <a href="#story">Story</a>
    <a href="#threat">Threat</a>
    <a href="#design">Design</a>
    <a href="#tokenomics">Policy</a>
    <a href="#run">Run</a>
  </nav>
</header>

<section class="hero" id="home" role="banner">
  <div class="hero-bg">
    <div class="bg-img"></div>
    <div class="glow one"></div>
    <div class="glow two"></div>
    <div class="mesh"></div>
    <div class="scan"></div>
  </div>

  <div class="hero-copy">
    <span class="chip">Layer-1 • Proof-of-Work • Post-Quantum</span>
    <h1 class="t">QUANTUM<span>COIN</span>™</h1>
    <p class="lead">
      A chain engineered for the quantum era: <b>post-quantum signatures</b>, a fixed <b>22,000,000</b> cap,
      <b>~10-minute</b> blocks, <b>2-year halvings</b> over ~<b>66 years</b>, and <b>RevStop™</b> — an
      owner-local safety circuit you control.
    </p>
    <div class="cta-row">
      <a href="#story" class="btn primary">Why QC</a>
      <a href="#design" class="btn ghost">See the Design</a>
    </div>

    <!-- Spinning coin (uses qc_coin.png) -->
    <div class="spin-wrap">
      <canvas id="coinSpin" width="320" height="320" aria-label="Spinning QuantumCoin emblem"></canvas>
    </div>
  </div>

  <div class="ticker" aria-hidden="true">
    <div class="track">
      <b>22M HARD CAP</b>
      <b>~10 MIN BLOCKS</b>
      <b>2-YEAR HALVING</b>
      <b>POST-QUANTUM SIGS</b>
      <b>REVSTOP™</b>
      <b>PRUNED / LIGHT NODES</b>
      <b>OPEN EXPLORER & API</b>
    </div>
  </div>
</section>

<section id="story" class="section card">
  <h2 class="h">The Story</h2>
  <p class="p">
    Ledgers outlive hardware generations. When large-scale quantum computers arrive, classical signatures
    become forgeable. Keys that look safe today could be <i>harvested now and drained later</i>. QuantumCoin™
    (QC) exists to keep a Bitcoin-style ethos—<b>no premine, predictable monetary policy, PoW fairness</b>—
    while upgrading the cryptography and the safety model <b>before</b> that moment arrives.
  </p>
  <p class="p">
    The design is simple on purpose: transparent issuance, widely runnable nodes, and a wallet-holder
    safety tool (<b>RevStop™</b>) that’s local to you, not a global kill switch.
  </p>
</section>

<section id="threat" class="section">
  <h2 class="h">The Quantum Threat (Plainly)</h2>
  <ul class="list">
    <li><b>Signature forgeries:</b> Shor’s algorithm could recover private keys from public keys and forge spends.</li>
    <li><b>Harvest-Now-Decrypt-Later:</b> attackers record data today, unlock it once quantum scales.</li>
    <li><b>Chain longevity:</b> monetary networks must be safe for decades, not product cycles.</li>
  </ul>
  <div class="pill-row">
    <span class="pill good">Act before it’s urgent</span>
    <span class="pill good">Post-quantum by default</span>
    <span class="pill good">Owner-local controls</span>
  </div>
</section>

<section id="design" class="section card">
  <h2 class="h">Design Response</h2>
  <div class="grid4">
    <div class="tile">
      <h3>PQ Signatures</h3>
      <p>Adopts post-quantum signature schemes to resist key-recovery and forgery attacks.</p>
    </div>
    <div class="tile">
      <h3>Proof-of-Work</h3>
      <p>Fair, permissionless distribution. Open hardware race with <b>~10-minute</b> blocks.</p>
    </div>
    <div class="tile">
      <h3>RevStop™</h3>
      <p>Owner-local “circuit breaker.” If your keys are compromised, <b>you</b> can temporarily stop spends
         for your UTXOs. Not a global freeze. Optional and verifiable.</p>
    </div>
    <div class="tile">
      <h3>Broad Nodes</h3>
      <p>Archival for explorers, <b>pruned</b> for lower storage, and <b>light/SPV</b> for phones—so more
         people can validate.</p>
    </div>
  </div>
</section>

<section id="tokenomics" class="section">
  <h2 class="h">Monetary Policy</h2>
  <div class="kv">
    <div><span>Supply Cap</span><b>22,000,000 QC</b></div>
    <div><span>Block Time</span><b>~10 minutes</b></div>
    <div><span>Halving</span><b>Every ~2 years</b></div>
    <div><span>Horizon</span><b>~66 years</b></div>
    <div><span>Premine</span><b>None</b></div>
    <div><span>Distribution</span><b>Proof-of-Work mining</b></div>
  </div>

  <!-- Calming animated neon grid (replaces the orbits) -->
  <div class="gridviz">
    <canvas id="matrixGrid" width="360" height="360" aria-label="Animated grid"></canvas>
    <p class="p small center">
      A living network grid — simple, readable, and easy on the eyes.
    </p>
  </div>
</section>

<section id="revstop" class="section card">
  <h2 class="h">RevStop™ in Detail</h2>
  <ul class="list">
    <li><b>Local, not global:</b> affects only UTXOs you control; protocol rejects conflicting spends while active.</li>
    <li><b>Opt-in:</b> wallets can enable/disable; no central authority required.</li>
    <li><b>Forensics-friendly:</b> on-chain signals help you and exchanges verify a protective pause, not a seizure.</li>
  </ul>
</section>

<section id="run" class="section">
  <h2 class="h">Run the Network</h2>
  <div class="node-cards">
    <div class="node">
      <b>Archival Node</b>
      <p>Complete history for research and block explorers; highest storage.</p>
    </div>
    <div class="node">
      <b>Pruned Node</b>
      <p>Validates the tip with a low storage footprint; ideal for most operators.</p>
    </div>
    <div class="node">
      <b>Light / SPV</b>
      <p>Phone-friendly verification using headers & proofs.</p>
    </div>
  </div>
  <div class="cta-row m12">
    <a class="btn primary" href="https://github.com/aeonith/quantumcoin-ui-" target="_blank" rel="noopener">GitHub</a>
    <a class="btn ghost" href="#home">Back to Top</a>
  </div>
</section>

<section id="roadmap" class="section card">
  <h2 class="h">Roadmap</h2>
  <ol class="road">
    <li><span class="dot"></span><b>Testnet</b> — PoW mining, PQ audits, pruned benchmarks.</li>
    <li><span class="dot"></span><b>Mainnet</b> — Genesis, explorer, wallets, independent reviews.</li>
    <li><span class="dot"></span><b>Tooling</b> — SDKs, reproducible builds, docs & integrations.</li>
  </ol>
</section>

<section id="legal" class="section">
  <h2 class="h">Notes</h2>
  <p class="p small">
    This site is informational and technical. It is not financial advice, an offer, or a solicitation.
    Timelines and features may evolve as research and review continue.
  </p>
</section>

<footer class="foot">
  <small>© <span id="y"></span> QuantumCoin™</small>
</footer>

<!-- ====== Scripts: spinning coin (image) + neon grid ====== -->
<script>
  document.getElementById('y').textContent = new Date().getFullYear();

  /* Spinning coin rendered from image (qc_coin.png) with neon rim + parallax tilt */
  (function(){
    const c = document.getElementById('coinSpin'); if(!c) return;
    const ctx = c.getContext('2d');
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    c.width *= DPR; c.height *= DPR; ctx.scale(DPR,DPR);

    const w = c.width / DPR, h = c.height / DPR, r = Math.min(w,h)/2 - 8;
    const img = new Image(); img.src = 'qc_coin.png';
    let t=0, mx=0, my=0;

    c.addEventListener('pointermove', e=>{
      const rect = c.getBoundingClientRect();
      mx = ((e.clientX-rect.left)/rect.width - .5)*2;
      my = ((e.clientY-rect.top)/rect.height - .5)*2;
    });

    function loop(){
      ctx.clearRect(0,0,w,h);

      const g = ctx.createRadialGradient(w/2, h/2, r*0.2, w/2, h/2, r*1.1);
      g.addColorStop(0,'rgba(34,211,238,.20)');
      g.addColorStop(1,'rgba(34,211,238,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(w/2,h/2,r*1.05,0,Math.PI*2); ctx.fill();

      ctx.save();
      ctx.translate(w/2 + mx*6, h/2 + my*6);
      ctx.rotate(t*0.8);

      const rim = ctx.createConicGradient(t,0,0);
      rim.addColorStop(0,'#22d3ee');
      rim.addColorStop(.5,'#60a5fa');
      rim.addColorStop(1,'#22d3ee');
      ctx.lineWidth = 8; ctx.strokeStyle = rim;
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();

      const size = r*1.8;
      ctx.drawImage(img, -size/2, -size/2, size, size);

      ctx.restore();
      t += 0.01;
      requestAnimationFrame(loop);
    }
    img.onload = loop;
  })();

  /* Animated neon grid: subtle, soothing, and not busy */
  (function(){
    const c = document.getElementById('matrixGrid'); if(!c) return;
    const ctx = c.getContext('2d');
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const wCSS = c.width, hCSS = c.height;
    c.width = wCSS * DPR; c.height = hCSS * DPR; ctx.scale(DPR, DPR);

    let t = 0;
    function draw(){
      const w = wCSS, h = hCSS;
      ctx.clearRect(0,0,w,h);

      const bg = ctx.createRadialGradient(w/2, h/2, 40, w/2, h/2, Math.max(w,h)*0.65);
      bg.addColorStop(0, 'rgba(34,211,238,0.08)');
      bg.addColorStop(1, 'rgba(34,211,238,0.00)');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      const gap = 22;
      const cols = Math.floor(w / gap);
      const rows = Math.floor(h / gap);
      const amp = 6;
      const speed = 0.018;

      for(let i=0;i<=cols;i++){
        for(let j=0;j<=rows;j++){
          const x = i * gap + (w % gap)/2;
          const yBase = j * gap + (h % gap)/2;

          const y = yBase
                  + Math.sin((i*0.45) + t)*amp*0.6
                  + Math.cos((j*0.55) - t*0.7)*amp*0.4;

          const dx = (x - w/2) / (w/2);
          const dy = (y - h/2) / (h/2);
          const falloff = Math.max(0, 1 - Math.sqrt(dx*dx + dy*dy));

          const r = 1.2 + 1.0*falloff;
          const hue = 190 - 12*falloff;
          ctx.fillStyle = `hsla(${hue}, 85%, ${60 + 10*falloff}%, ${0.75*falloff + 0.15})`;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI*2);
          ctx.fill();

          const g = ctx.createRadialGradient(x, y, 0, x, y, 8);
          g.addColorStop(0, `hsla(${hue}, 85%, 60%, ${0.11*falloff})`);
          g.addColorStop(1, 'transparent');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, 8, 0, Math.PI*2);
          ctx.fill();
        }
      }

      t += speed;
      requestAnimationFrame(draw);
    }
    draw();
  })();
</script>
</body>
</html>